// huffman_unpack.go (deterministic version)
package mainw

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"os"
)

// ===== 노드 =====
type Node struct {
	c           byte
	f           uint32
	left, right *Node
	order       int // 동일 freq 타이브레이크용 삽입 순서
}

// ===== MinHeap (파이썬 동작과 동일 + order 타이브레이크) =====
type MinHeap struct {
	arr []*Node
	seq int // push될 때 부여되는 증가 id
}

func (h *MinHeap) size() int { return len(h.arr) }

func le(a, b *Node) bool { // a <= b
	if a.f != b.f {
		return a.f <= b.f
	}
	return a.order <= b.order
}
func lt(a, b *Node) bool { // a < b
	if a.f != b.f {
		return a.f < b.f
	}
	return a.order < b.order
}

func (h *MinHeap) push(n *Node) {
	n.order = h.seq
	h.seq++

	h.arr = append(h.arr, n)
	childIdx := h.size() - 1

	for {
		if childIdx <= 0 {
			return
		}
		parentIdx := (childIdx - 1) / 2
		if le(h.arr[parentIdx], h.arr[childIdx]) { // parent <= child 이면 stop (파이썬과 동일)
			return
		}
		h.arr[parentIdx], h.arr[childIdx] = h.arr[childIdx], h.arr[parentIdx]
		childIdx = parentIdx
		if childIdx <= 0 {
			return
		}
	}
}

func (h *MinHeap) pop() *Node {
	if h.size() == 0 {
		return nil
	}
	obj := h.arr[0]
	last := h.arr[h.size()-1]
	h.arr = h.arr[:h.size()-1]
	if h.size() == 0 {
		return obj
	}
	h.arr[0] = last

	parentIdx := 0
	childIdx := 2*parentIdx + 1
	for childIdx < h.size() {
		if childIdx+1 < h.size() {
			if lt(h.arr[childIdx+1], h.arr[childIdx]) { // 더 작은 자식 선택, 같으면 왼쪽 유지
				childIdx++
			}
		}
		if le(h.arr[parentIdx], h.arr[childIdx]) { // parent <= child 면 stop
			return obj
		}
		h.arr[parentIdx], h.arr[childIdx] = h.arr[childIdx], h.arr[parentIdx]
		parentIdx = childIdx
		childIdx = 2*childIdx + 1
	}
	return obj
}

// ===== 순서를 유지하며 트리 구성 =====

type freqEntry struct {
	c byte
	f uint32
}

func makeTreeOrdered(entries []freqEntry) *Node {
	h := &MinHeap{}
	// 파일에서 읽힌 순서대로 push (결정성 보장)
	for _, e := range entries {
		h.push(&Node{c: e.c, f: e.f})
	}
	for h.size() > 1 {
		a := h.pop()
		b := h.pop()
		n := &Node{f: a.f + b.f, left: a, right: b}
		h.push(n) // 새 노드도 push 시 order 자동 부여
	}
	return h.pop()
}

// ===== MSB-first bit reader =====

type bitReader struct {
	data []byte
	bits int
	pos  int
}

func newBitReader(p []byte, bits int) *bitReader {
	return &bitReader{data: p, bits: bits}
}

func (br *bitReader) readBit() (bool, error) {
	if br.pos >= br.bits {
		return false, io.EOF
	}
	byteIdx := br.pos / 8
	bitOff := br.pos % 8
	b := br.data[byteIdx]
	bit := (b>>(7-uint(bitOff)))&1 == 1 // MSB-first
	br.pos++
	return bit, nil
}

func decode(tree *Node, packed []byte, bitCount int) (string, error) {
	if tree == nil {
		return "", errors.New("invalid tree: empty")
	}
	br := newBitReader(packed, bitCount)
	out := make([]byte, 0, 1024)

	for br.pos < br.bits {
		node := tree
		for {
			if node.left == nil && node.right == nil {
				break
			}
			bit, err := br.readBit()
			if err == io.EOF {
				return "", fmt.Errorf("invalid tree: out of message bounds, unpacked=%q", string(out))
			}
			if err != nil {
				return "", err
			}
			if bit {
				node = node.right
			} else {
				node = node.left
			}
			if node == nil {
				return "", fmt.Errorf("invalid tree: dead end while walking, unpacked=%q", string(out))
			}
		}
		out = append(out, node.c)
	}
	return string(out), nil
}

// ===== 리틀엔디언 uint32 =====

func readU32(r io.Reader) (uint32, error) {
	var v uint32
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return 0, err
	}
	return v, nil
}

// ===== 헤더 파싱 (순서 유지) =====

func getFreqsOrdered(r io.Reader) ([]freqEntry, error) {
	// file_len, always0, chars_count
	if _, err := readU32(r); err != nil { // file_len
		return nil, err
	}
	if _, err := readU32(r); err != nil { // always0
		return nil, err
	}
	charsCount, err := readU32(r)
	if err != nil {
		return nil, err
	}

	entries := make([]freqEntry, 0, charsCount)
	for i := uint32(0); i < charsCount; i++ {
		cnt, err := readU32(r)
		if err != nil {
			return nil, err
		}
		var c [1]byte
		if _, err := io.ReadFull(r, c[:]); err != nil {
			return nil, err
		}
		// padding 3 bytes
		var pad [3]byte
		if _, err := io.ReadFull(r, pad[:]); err != nil {
			return nil, err
		}
		entries = append(entries, freqEntry{c: c[0], f: cnt})
	}
	return entries, nil
}

func unpackFromReader(r io.Reader) (string, error) {
	entries, err := getFreqsOrdered(r)
	if err != nil {
		return "", err
	}
	tree := makeTreeOrdered(entries)
	if tree == nil {
		return "", errors.New("empty frequency table")
	}

	packedBits, err := readU32(r)
	if err != nil {
		return "", err
	}
	packedBytes, err := readU32(r)
	if err != nil {
		return "", err
	}
	// unpackedBytes(검증용)은 읽기만 하고 사용하지 않아요.
	if _, err := readU32(r); err != nil {
		return "", err
	}

	packed := make([]byte, packedBytes)
	if _, err := io.ReadFull(r, packed); err != nil {
		return "", err
	}

	return decode(tree, packed, int(packedBits))
}

func unpackBytes(data []byte) (string, error) {
	return unpackFromReader(bytes.NewReader(data))
}

// ===== 데모 & CLI =====

func main() {
	// 인자가 있으면 파일에서 읽고, 없으면 데모 벡터 실행해요.
	if len(os.Args) > 1 {
		path := os.Args[1]
		f, err := os.Open(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "파일 열기 실패: %v\n", err)
			os.Exit(1)
		}
		defer f.Close()
		out, err := unpackFromReader(f)
		if err != nil {
			fmt.Fprintf(os.Stderr, "언팩 실패: %v\n", err)
			os.Exit(1)
		}
		fmt.Println(out)
		return
	}

	test := []byte{
		0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
		0x30, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x37, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x85, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00,
		0xD3, 0x0C, 0x78, 0x90, 0xFB, 0x1D, 0x0E, 0x6E, 0x4B, 0x4C, 0x35, 0xDF,
		0x17, 0x75, 0xBD, 0xAA, 0x90,
	}
	out, err := unpackBytes(test)
	if err != nil {
		fmt.Fprintf(os.Stderr, "데모 언팩 실패: %v\n", err)
		os.Exit(1)
	}
	fmt.Println(out) // 기대값: 53801-198-55428-4050|53802-0-17725-70000|
}
